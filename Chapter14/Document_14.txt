14-1. [DC]
: 출력에 필요한 모든 정보를 가지는 구조체, 모든 출력 함수는 DC를 참조하여 출력을 내보낸다.
- 특징
* 사용자가 직접 DC의 속성값을 변경 할 수는 없으며DC의 속성을 설정하는 여러 가지 함수를 사용하여 간접적으로 조작해야 한다.
* 운영체제가 관리한다.

[DC 종류]
- 디스플레이 DC, 프린터 DC, 메모리 DC, 정보 DC

[디스플레이 DC]
- CommonDC
- PrivateDC
- ClassDC
- WindowDC
- ParentDC

[CommonDC]
: 작업영역에 그리기를 하는 가장 보편적인 DC
- 사용할 때만 핸들을 받아 사용하고 사용이 끝난 후 해제해 버리기 때문에 DC에 설정된 속성은 DC가 해제될 때 같이 사라진다.
- 특별한 경우를 제외하고는 CommonDC를 사용한다.
ex)
DC생성 후 빨간펜 파란색 브러시를 선택하고 그림을 그린 후 DC가 해제되면 이 펜이나 브러시에 대한 설정도 같이 없어지며
다음번 DC를 발급받을 때는 모두 디폴트값으로 재설정된다.

[PrivateDC]
: 윈도우 클래스의 스타일에 CS_OWNDC 스타일을 지정한다.
- 이 윈도우 클래스로부터 윈도우가 만들어질 때마다 OS는 PrivateDC를 생성한다.(윈도우 단위로 사용하는 DC)
- 따로 해제 할 필요 없이 윈도우 파괴시 자동 파괴됨.

[ClassDC]
: PrivateDC와 유사한 특징을 가지고 있다. 윈도우 클래스의 스타일에 CS_CLASSDC플래그를 주면 이 윈도우 클래스로부터 만들어지는
모든 윈도우의 클래스 DC를 사용한다.
- 권장되지 않음.

[WindowDC]
: CommonDC와 사용방법이 비슷하다.
- 원점이 윈도우의 좌상단이며, 클리핑 영역이 작업영역에만 국한되는 것이 아니라 전체 윈도우이다.
(그래서 타이틀바같은 영역에도 그리기가 가능함. ※과거에는)
- HDC GetWindowDC(HWND)

[ParentDC]
: 클리핑 영역을 계산하는 시간을 최소화하기 위해 사용함
- 최상위 윈도우나 팝업 윈도우는 이 DC를 사용할 수 없다. 클래스 스타일에 CS_PARENTDC 플래그 지정
- ParentDC 발급 시 부모 윈도우가 사용하던 DC를 캐시에서 찾아 이미 계산되어 있는 클리핑 영역을 사용함으로써 최대한 시간을 아낌
- 일반적으로 부모 윈도우가 먼저 그리기를 하므로 캐시에 부모 윈도우의 DC가 있을 확률이 높다.
만약 캐시에서 부모 윈도우의 DC가 발견되지 않으면 커먼 DC가 대신 발급된다.
이론적으로 ParentDC를 사용하면 차일드 윈도우가 부모 윈도우의 작업영역에 마음대로 그리기를 할 수 있는데
이런식으로 사용해서는 안 된다.

- int GetDeviceCaps(HDC hdc, int nIndex);
: DC의 특성을 파악해야 할 때 호출함


14.2 [WM_PAINT]

[무효영역]
-> 윈도우가 다시 그리기를 하는 경우
- 윈도우가 처음 생성되었을 때
- 윈도우의 위치가 이동되었을 때
- 윈도우의 크기가 변경되었을 때 최대, 최소화되었을 때
- 다른 윈도우에 가려져 있다가 드러날 때. 즉, 언커버될 때
- 스크롤 될 때
- 응용프로그램이 직접 무효화를 할 때
그 외 기타 등등...

윈도우즈는 아주 효율적인 그리기를 위해 복잡한 매커니즘을 사용한다.
그 중 가장 먼저 이해해야 하는 것이 "무효영역(Invalid-Region = Update-Region)" 이다.

- InvalidateRect(HWND hWnd, CONST RECT* lpRect, BOOL bErase);
: hWnd 윈도우의 lpRect 영역을 무효화하여 다시 그리도록 하는 함수이다.
두번째 인수에 NULL을 주면 전체 작업영역을 무효화 한다.

만약 SendMessage(hWnd, WM_PAINT, 0, 0);
이런 메시지를 보낸다면 WM_PAINT메시지를 처리하면서 윈도우를 다시 그릴까?
정답은 NO~!!!!
윈도우즈는 무효영역이 없으면 다시 그리지 않는다.

InvalidateRect() 함수의 반대 함수는 다음과 같다.
- BOOL ValidateRect(HWND hWnd, CONST RECT *lpRect);
: 유효화 시키는 함수 (유효화가 목적이기 보다는 더 효율적인 무효화를 위한 실용적인 함수임)


- BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
- BOOL ValidateRgn(HWND hWnd, HRGN hRgn);
: InvalidateRect() 함수가 사각 영역을 무효화 하는 데 비해 InvalidateRgn() 함수는 리전을 무효화한다.
리전이란 곡선 및 분리된 영역을 말하는데 좀 더 복잡한 형태의 무효화를 할 수 있다.
(추후~ 자세히)


[WM_PAINT 메시지가 보내지는 시점]
WM_PAINT 메시지는 모든 메시지 중에서 가장 우선 순위가 꼴찌인 메시지이다.
WM_PAINT보다 우선 순위가 늦은 유일한 메시지는 WM_TIMER뿐이다.
윈도우즈가 응용 프로그램으로 WM_PAINT 메시지를 보내는 경우는 두 가지 조건이 충족되었을 때이다.
1. 메시지 큐에 대기중인 메시지가 없어야 한다.
사용자가 키보드 입력을 하고 있거나 마우스 조작을 하고 있는 동안에는 화면 그리기를 하지 않는다.
사용자의 입력 처리가 화면 그리기보다 훨씬 더 중요하기 때문이다.
ex)
L, M, P, K 순으로 메시지 큐에 대기중이라고 가정하자.

큐의 동작 원리에 따라 가장 먼저 꺼내지는 메시지는 "K" 키보드 메시지 이다.
두번째는 동작원리에 따라 P인데 뒤쪽에 다른 메시지가 대기중이므로
이를 꺼내서 먼저 처리한다.
그리고 나서 더 이상 처리할 메시지가 없을 떄 WM_PAINT가 꺼내진다.

큐는 일반적으로 먼저 들어간 값이 먼저 나오지만 WM_PAINT는 이런 큐 메커니즘의 예외이며
큐에서 메시지를 꺼내는 GetMessage 함수가 이 예외를 적용한다.

2. 무효영역이 있어야 한다.
무효영역이 없는 상태이거나 있다 라더라도 그릴 필요가 없는 영역이면
WM_PAINT는 전달되지 않는다.

>>>> WM_PAINT 메시지 발생 원리
WM_PAINT를 큐에 넣는 주체는 OS이며 응용 프로그램이 직접 WM_PAINT 메시지를 큐에 넣지는 않는다.
응용 프로그램은 다만 무효영역을 만들 뿐이며 무효영역이 있으면 WM_PAINT가 메시지 큐에 자동으로 들어간다.
메시지 루프는 메시지 큐에서 메시지를 꺼내와 WndProc으로 보내는데
그러다가 메시지 큐가 비면 무효영역이 있는지 살펴보고 무효영역이 있을 경우 WM_PAINT 메시지를 WndProc으로 보낸다.
그래서 다시 처리해야 할 부분을 무효화해 놓기만 하면
윈도우즈가 적당한 때에 WM_PAINT 메시지를 보내 다시 그리도록 한다.

※ 정리하면 WM_PAINT를 발생시키는 주체는 OS이고 발생 원리는 응용 프로그램이 무효영역을 만들었는가 이다.
무효 영역이 있으면 WM_PAINT를 메시지 큐에 넣고, 메시지 루프는 큐가 비어있고, 무효영역이 있는지 살펴본 후
WndProc()로 전달한다.

[WM_PAINT 통합]
WM_PAINT 메시지는 메시지 큐에 결코 두 개 이상 들어가지 않는다.
윈도우즈는 두 개의 WM_PAINT 메시지가 큐에 있으면 이 둘을 합쳐 하나로 만들되 
두 메시지가 가진 무효영역의 합집합을 새로운 무효영역으로 설정한다.

ex)
rt1을 무효화하면 운영체제가 rt1을 다시그리는 WM_PAINT 메시지를 큐에 삽입한다.
이 상태에서 다시 그리기를 하기 전에 rt2를 무효화하면 또 rt2를 다시그리는 WM_PAINT 메시지가 큐에 들어가는 것이 아니라
기존의 rt1에 대한 WM_PAINT가 rt1과 rt2를 동시에 그리도록 변경된다.

InvalidateRect()를 호출한다고 즉시 그리기를 하지 않으며 무효영역을 최대한 모아서 한꺼번에 그리므로
무효화를 여러번 나누어해도 무관하다.
불필요한 그리기를 한번이라도 줄여 운영체제의 전반적인 속도를 높이기 위해서인데
이런 메시지 통합은 WM_TIMER에도 똑같이 적용된다.
운영체제가 WM_PAINT를 처리하는 방식이 굉장히 지능적이다.

※ 화면이 무효화되는 시점과 그려지는 시점은 다르다. (비동기적)

[UpdateWindow() 함수]
무효영역이 있더라도 다른 메시지가 큐에 있다면 WM_PAINT메시지는 대기중인 메시지가 처리되는 동안에는 보내지지 않는다.
무효화 시점과 그려지는 시점의 시차가 아주 작더라도 문제가 되는 경우도 있다.
이럴 때 무효화되는 즉시 화면을 다시 그리게 할 수 있는데 이 떄 사용하는 함수가 UpdateWindow()이다.
이 함수는 WM_PAINT를 메시지 큐를 거치지 않고 곧바로 WndProc으로 보내므로 
다른 메시지보다 우선해서 WM_PAINT 메시지를 처리하도록 한다.

ex)
case WM_LBUTTONDOWN:
	bRect = !bRect;
	SetRect(&rt, 10, 10, 100, 100);
	InvalidateRect(hWnd, &rt, TRUE);
	Sleep(1000);
	return 0;
>>> 이렇게 하면 마우스 클릭 후 사각 영역이 무효화되고 1초후에 다시 그리게 될 것이다.

만약 즉시 그리기를 원한다면 다음과 같이 변경한다.
case WM_LBUTTONDOWN:
	bRect = !bRect;
	SetRect(&rt, 10, 10, 100, 100);
	InvalidateRect(hWnd, &rt, TRUE);
	UpdateWindow(hWnd); // <<<<<<<<<<<
	Sleep(1000);
	return 0;

기본적으로 UpdateWindow 함수는 개념적으로 SendMessage(WM_PAINT)와 비슷하지만
무효영역이 없을 경우에 UpdateWindow 함수는 WM_PAINT를 보내지 않는다.


[클리핑 영역]
무효 영역(Update Region)이란 다시 그려져야 할 부분이다.
그런데 운영체제가 실제 그리기에 사용하는 영역은 무효영역이 아니라 클리핑 영역이다.
클리핑 영역은 무효영역중에서도 화면에 보이는 가시 영역을 말한다.
즉 무효영역과 가시 영역의 교집합이 클리핑 영역이다.

ex)
무효영역중 비가시영역을 제외한 이 부분을 클리핑 영역이라고 부른다.
클리핑 영역 바깥은 설령 무효영역이라도 그리기 영역에서 잘려나간다.(Clip 된다)
운영체제는 무효화 영역 중 최소한의 영역만 그리고 다른 윈도우 영역을 침범하지 않기 위해 클리핑 영역을 사용한다.

무효형역은 운영체제에 의해 설정되거나 응용 프로그램이 InvalidateRect 등의 함수로 직접 설정하며 
클리핑 영역은 BeginPaint에 의해 계산된다.
이렇게 계산된 클리핑 영역은 DC에 선택되며 모든 GDI 함수들은 클리핑 영역을 참고하여
자신이 그리지 말아야 할 부분을 잘라낸다.

※ 클리핑 영역 = 무효 영역 + 가시 영역

[윈도우 스타일]
윈도우의 WS_CLIPCHILDREN 스타일을 가지면 차일드의 영역을 클리핑 영역에서 제외함으로써 
차일드가 불필요하게 다시 그려지지 않도록 한다. (부모 윈도우에 추가)

WS_CLIPCHILDREN << 깜박임없는 프로그램을 만드는 가장 기본적인 방법

CS_HREDRAW | CS_VREDRAW : 윈도우 크기 변경 시 전체 작업영역을 무효화하여 다시 그리기를 한다는 윈도우 클래스 스타일
이 스타일을 지정하는 것이 가장 보편적이다.


[PAINTSTRUCT]
BeginPatin 함수를 통해 PAINTSTRUCT 구조체의 포인터를 인수로 취하는데 잘 활용하면
그리기 속도를 비약적으로 개선할 수 있다.
typedef struct tagPAINTSTRUCT {
	HDC hdc;
	BOOL fErase;
	RECT rcPaint;
	...
} PAINTSTURCT;
: 그리기에 사용될 DC 핸들, 배경을 지울지에 대한 여부(TRUE면 배경을 직접 지워야 함), 클리핑 영역
>> rcPaint 참고

화면 전체에 픽셀을 찍고 찍을 때 마다 Swap()을 10번씩 하기 때문에 작업을 완료하는데 오래 걸린다.
만약 화면의 일부를 무효화하면 무효화 한 부분을 다시 그리지만 쓸데없이 전체 루프를 반복하기 때문에
시간이 낭비된다.

이 때 PAINTSTRUCT구조체의 rcPaint 멤버를 사용하면
클리핑 영역에 대해서만 루프를 돌게되어 실행 시간을 아낄 수 있다.


[BeginPaint]
굉장히 중요한 함수이다.

1. 그리기를 위해 DC를 발급받는다. 이 DC 핸들은 BeginPaint의 리턴값으로 돌려지기도 하며
PAINTSTRUCT 구조체의 hdc 멤버에도 대입되는데 이 DC 핸들을 사용하여 그리기를 하면 된다.
또한 PAINTSTRUCT 구조체의 fErase, rcPaint를 조사해서 채운다.

2. 클리핑 영역을 조사하여 DC에 설정한다. 모든 출력 함수는 DC에 설정된 클리핑 영역을 참고하여
영역 바깥으로 출력되는 것을 잘라낸다. 이때 무효영역, 윈도우의 Z 순서, 보이기 상태 등의 여러 가지 정보를 참조한다.

3. 무효영역을 없애(=유효화한다) 다시 WM_PAINT 메시지가 호출되지 않도록 한다. 만약 화면만 다시 그리고
무효영역을 그대로 내버려두면 운영체제는 계속해서 WM_PAINT 메시지를 보낼 것이다.

4. 다시 그려지는 영역에 캐럿이 있다면 그리기를 시작하기 전에 숨겨 캐럿이 파괴되지 않도록 한다.
이렇게 숨겨진 캐럿은 그리기를 끝내는 시점인 EndPaint에 의해 복구된다.

5. 윈도우의 배경을 백그라운드 브러시로 지우기 위해 WM_ERASEBKGND 메시지를 보내 처리한다.
또한 WM_NCPAINT 메시지를 보내 비작업영역을 그리도록 한다.

이 중에서도 특히 무효영역을 없애는 기능이 중요하다.
응용 프로그램이나 운영체제에 의해 설정된 무효영역은 WM_PAINT의 BeginPaint 함수에 의해 제거됨으로써
새로운 무효영역이 생기기 전에는 WM_PAINT 메시지가 전달되지 않는다.
무효영역이 있음으로써 WM_PAINT 메시지가 발생하는데 WM_PAINT 메시지 처리 루틴에서 무효영역을 없애지 않는다면
WM_PAINT 메시지가 계속 발생 할 것이다.
WM_PAINT 메시지의 목적이 다시 그리기, 즉 바꾸어 말하면 무효영역을 유효영역으로 만드는 것임을 생각해보면
BeginPaint가 무효영역을 없애는 것은 당연하다.

이런 이유로 WM_PAINT에서는 반드시 BeginPaint 함수를 사용하여 DC를 얻어야 하며 GetDC를 사용해서는 안 된다.
BeginPaint는 단순히 DC를 발급받는 것 이상의 중요한 일을 하기 때문이다. 또한
BeginPaint 함수가 WM_PAINT 메시지 내에서만 사용하기 위해 만들어진 함수이므로 이 메시지 외부에서는 사용할 수 없다.

EndPaint BeginPaint가 발급받는 DC를 해제하고 캐럿(키보드 입력을 받는 깜박이는 부분-메모장)을 다시 나타낸다.
BeginPaint를 호출했으면 반드시 EndPaint도 호출해야 한다. 아무것도 그릴 것이 없을 때는
WM_PAINT에 BeginPaint와 EndPaint 호출만 두면 된다. 다른 메시지와는 달리 그릴 게 없다고 하더라도 
다음과 같이 메시지 처리 코드를 비워 두어서는 안된다.
case WM_PAINT:
	return 0;

이렇게 하면 아무것도 하지 않고 바로 리턴함으로써 그리기를 하지 않을 것 같지만
무효영역이 유효화되지 않으므로 WM_PAINT 메시지가 무한히 날라올 것이다. WM_PAINT에서 카운트를 증가시켜
타이틀바에 출력해 보면 이 메시지가 계속 발생하는 것을 확인할 수 있다. 또한 BeginPaint 대신
GetDC를 사용해도 마찬가지 결과가 나타난다.
그릴 것이 없다면 차라리 이 메시지를 처리하지 말고 DefWindowProc으로 보내야 한다.
디폴트 처리 루틴은 WM_PAINT에 대해 BeginPaint, EndPaint를 차례대로 호출하도록 되어 있다.


[그리기 메시지]
BeginPaint가 하는 일 중에 다섯 번째가 WM_NCPAINT 메시지와 WM_ERASEBKGND 메시지를 보내는 것이다.
응용 프로그램은 WM_NCPAINT 메시지를 받았을 때 타이틀 바, 경계선, 시스템 메뉴 등을 그려야 한다.
다행이 이 메시지는 우리가 처리하지 않아도 DefWindowProc에서 처리하며 대부분의 응용 프로그램이
이 메시지를 처리하지 않는다.
>>> RedFrame(동작 안함)

WM_ERASEBKGND 메시지 : 윈도우 클래스에 등록된 배경 브러시로 작업영역의 배경을 지우는 역할
새로운 그림을 그리기 전에 그려져 있는 그림을 지워야 한다.
이 메시지도 그냥 DefWindowProc으로 보내주기만 하면 된다.
만약 WM_ERASEBKGN에서 return 0;으로 처리해버리면 배경이 지워지지 않는다.
>>> EraseBk
결과를 확인해보면 뻥뚫린 윈도우를 보게 된다.
이는 투명화가 아닌 그저 아무 처리도 하지 않는 방치 상태이다.

wParam으로 DC 핸들이 전달되는데 이 값을 받아서 사용하고 해제할 필요는 없다.
응용 프로그램이 WM_ERASEBKGND 메시지를 처리했으면 반드시 0이 아닌 값을 리턴하여 배경이 지워졌다는 것을 알려야 한다.
그렇지 않으면 운영체제는 배경이 아직 지워지지 않았다고 생각하게 될 것이며
PAINTSTRUCT의 fErase 멤버가 계속 TRUE값을 가지게 된다. 이 경우 WM_PAINT에서 배경을 직접 지워야 한다.

이때 wParam으로 전달되는 DC를 사용하는 이유는
GetDC로 직접 처리하면 정상적으로 동작하는 것 같지만
클리핑 영역이 설정되지 않아 WM_ERASEBKGND 메시지 외에 다른곳에서 그린 부분들이 배경에 의해 전부 덮여 버린다.
WM_ERASEBKGND의 wParam으로 전달되는 DC는 BeginPaint가 클리핑 영역을 계산해 놓은 DC라 
바깥쪽은 그리지 않도록 되어 있으므로 이런 문제가 없다.


[GetDC]
: WM_PAINT 외부에서 그리기를 원할 때 사용
>> GetDCEx(), WindowFromDC() 참고
ex)
GetDCEx(hWnd, NULL, DCX_WINDOW | DCX_CACHE);로 DC를 얻으면 비작업영역에 그리기를 할 수 있는 윈도우 DC가 생성되며
GetWindowDC와 동일하다.


[그리기 정보의 보관]
Mouse예제를 보면 윈도우의 작업 영역을 다시 그리게 되면 
기존의 그려진 내용을 상실하게 된다. 이를 개선한 Mouse2 예제를 만들어 보자.

Mouse3예제에서는 메모리 비트맵을 통해 그리고, 다시 그릴 때 비트맵을 복사만 하면 된다.


[DC관리]
[LookWindowUpdate]
: 화면그리기를 허가/금지할 때 사용하는 함수
- BOOL LockWindowUpdate(HWND hWndLock);

그리기 금지된 윈도우는 GetDC나 BeginPaint로 DC 핸들을 받을 때 가시 영역이 비어있는 DC를 발급받는다.
가시 영역이 비었으므로 무효영역과는 상관없이 클리핑 영역도 당연히 NULL이 되고 따라서 어떠한 출력도
화면으로 나갈 수 없는 상태가 된다.

락을  해제하려면 그 함수를 다시 한 번 더 호출하되 인수로 NULL값을 주면 된다.
락은 한번에 하나의 윈도우에만 걸 수 있으므로 NULL 윈도우에 락을 건다는 것은 곧 락을 해제한다는 의미이다.
운영체제는 락이 걸려 있는 윈도우의 모든 출력을 감시한 후 출력이 나간 모든 영역을 차곡차곡 모아둔다.
그리고 락이 해제되면 이 영역이 일시에 무효화되어 한꺼번에 그리기를 한다.


[SaveDC]
: DC에는 그리기에 필요한 많은 정보들이 포함되어 있는데 이를 교체하는 것이 좀 번거롭다.
그래서 기존 DC 상태를 저장해 놓고 그 설정 살태를 불로 올 수 있는 함수가 있다.
int SaveDC(HDC hdc);
BOOL RestoreDC(HDC hdc, int nSavedDC);

- SaveDC()는 말그대로 DC의 모든 설정 상태를 스택에 저장해 놓는다.
그리고 일종의 저장 핸들에 해당하는 정수값 하나를 리턴한다.
이렇게 저장된 DC 상태는 언제든지 RestoreDC 함수로 불러올 수 있다.


[CreateDC]
- DC를 생성하는 함수
- HDC CreateDC(LPCTSTR lpszDriver, LPCTSTR lpszDevice, LPCTSTR lpszOutput, CONST DEVMODE *lpInitData);
이 함수는 주로 프린터 DC를 만들 때 사용하는데
화면 DC를 만들 때도 쓸 수 있다.
인수의 의미가 대단히 어렵고, Win16의 잔재도 남아있기에 쓰지 않는 인수도 있어서 자세히 알려고 하면 피곤하다.

CreateDC("DISPLAY", NULL, NULL, NULL)이라고 호출하면 전체 화면에 대한 DC를 얻을 수 있다는 것만 알면 된다.
(자세한 내용은 래퍼런스 참조)

+추가 >> ScreenToy 예제 참조
>> ScreenToy


[과제] SimplePaint4
선의 굵기와 색상을 모달 대화상자로 선택할 수 있는 SimplePaint2 예제를 확장하여 그려진 선의 정보를 저장하도록 하라.
선의 색상과 굵기, 좌표 등을 모두 저장하여 사용자가 그린 그림을 완벽하게 복구할 수 있어야 한다.
선의 개수에 상관없이 무한대의 길이로 저장할 수 있는 자료 구조를 선택 하라.

[과제] RopMode3
6장의 RopMode2 과제를 수정하여 도형의 정보를 내부 자료 구조에 저장하고 언커버되었을 때 복구해 보아라.
형태가 다른 여러 가지 도형의 정보를 같이 저장해야 하므로 자료 구조가 좀 더 치밀해져야 한다.