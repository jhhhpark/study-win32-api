[윈도우의 구성요소]
작업 영역, 타이틀 바, 시스템 메뉴, 메뉴바, 수직 스크롤 바, 경계선, 최소/최대화 버튼, 닫기 버튼 등등

[윈도우 클래스]
윈도우 클래스 = 형틀

[시스템 전역 클래스(System global class)]는 운영체제가 부팅될 때 등록되며 주로 컨트롤을 만들 때 사용되는 클래스.
<모든 프로세스에서 사용할 수 있는 시스템 클래스>
ex) button, edit, listbox, scrollbar, static, ComboBox, MDIClient

<시스템에서만 사용할 수 있는 시스템 클래스>
ex) Message, DDEMLEvent, #32768 등


[애플리케이션 전역 클래스(Application global class)]는 주로 DLL에 의해 등록되며
프로세스의 모든 모듈에서 이 클래스를 사용할 수 있다.

[애플리케이션 로컬 클래스(Application local class)]는 응용 프로그램 
자신이 메인 윈도우나 차일드 또는 커스텀 컨트롤을 만들기 위해 프로그램 선두에서 등록하는 클래스.

Windows OS는 윈도우 클래스가 두 개 이상이라면(이름이 같은) App Local -> App Global -> System Global 순으로 찾음
이러면 내가 만든 클래스를 대체(override)하려면 다음과 같이하면 된다.
"button"이라는 이름으로 로컬 클래스를 정의하면 모든 버튼 컨트롤이 시스템 전역 클래스로부터 생성되는 것이 아니라
새로 정의한 "button" 로컬 클래스로부터 생성될 것이다.
(근대 이건 별로 바람직하지 못한 방법이다.)


WindowClass 등록 시 핵심 사항은 다음과 같다.
윈도우 클래스 이름, 윈도우 클래스의 고유 프로시저, 인스턴스 핸들


WNDCLASSEX는 WNDCLASS 구조체를 확장한 구조체이다.
추가 멤버로 cbSize와 hIconSm 멤머가 추가되어있다.
cbSize : 버전 확인을 위해 구조체의 크기를 지정하는 멤버인데 Win32 API는 구조체 버전 확인을 위해 첫 번째 멤버에
구조체의 크기를 대입하는 방법을 흔히 사용한다.
구조체에 새로운 멤버가 생기면 당연히 크기가 늘어나니까 윈도우 구조체 확장 버전인지 확인 가능하다.
WndClassEx.cbSize = sizeof(WNDCLASSEX)라고 하면 된다는 의미
=> 만약 이 크기가 정확하지 않으면 구조체가 무효해지고 윈도우 생성을 실패하게 된다.

사실 작은 아이콘을 지정한다는 것 외에는 WNDCLASS와 큰 차이는 없다.


>>>>윈도우 클래스는 등록후에도 설정한 속성값들을 수정할 수 있다.
[DWORD SetClassLong(HWND hWnd, int nIndex, LONG dwNewLong)]
[DWORD GetClassLong(HWND hWnd, int nIndex)]

↑위의 함수는 사용하지 말고 64비트를 지원하는 ↓함수를 사용하자.

[ULONG_PTR SetClassLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNewLong)]
[LONG_PTR GetClassLongPtr(HWND hWnd, int nIndex)]
hWnd : 소속 윈도우
nIndex : 조사하거나 설정하고자 하는 값
GCL로 시작하는 값 : 32bit 고정, GCLP_는 운영체제 버전에 따라 32비트 또는 64비트가 될 수 있다.


위처럼 윈도우 속성은 한번 정하면 고정되는 정적인 속성이 아니라 동적인 것이다.!!!!!!

약간의 고급 기법으로 cbClsExtra에 여분 메모리를 등록한 후 이 메모리를 사용하는 기법이 있다.
이런 식으로 lpfnWndProc을 변경하여 윈도우의 기본 동작에 변화를 주는 방법을 서브 클래스(SubClassing)이라고 한다.


[윈도우의 스타일]
윈도우의 스타일은 WS_로 시작되는 일반적인 윈도우 스타일이 있고,
그 외 버튼, 리스트 박스, 에디트에 등의 컨트롤에만 적용되는 스타일이 있다.(ES_, LBS_, 등 컨트롤의 접두어를 붙임)
(윈도우 스타일은 winuser.h 참고)

상위 16비트에 정의 되어 있으며 하위 16비트는 컨트롤의 스타일 정의에 사용되는데 컨트롤별로 의미가 다르다.


> 윈도우 종류
WS_OVERLAPPEDWINDOW : 윈도우 스타일이 묶여있는 복합 스타일
WS_OVERLAPPED : 디폴트 0 (예전에는 윈도우가 겹치지 않았었고, 2.0 이후를 기념하기 위해 추가됨)
WS_POPUP, WS_CHILD : 오버랩드가 아닌 윈도우는 둘 중 하나가 된다. 둘다 성질이 비슷하기 때문에 동시에 쓸 수는 없다.
(윈도우를 크게 3종류로 나누면 오버랩드, 차일드, 팝업)

WS_CHILD : hParent인수에 부모를 꼭 지정해야 함. 부모 윈도우의 작업 영역을 벗어날 수 없음
WS_POPUP : 다이얼로그, 메시지 박스처럼 부모 윈도우의 작업 영역을 벗어날 수 있다.
항상 부모 윈도우보다 Z순서가 빠르므로(수직적으로 위에 위치)부모에 의해 가려지지 않음


> 경계선 스타일
WS_BORDER, WS_DLGFRAME, WS_THICKFRAME 세가지가 있고, 확장 스타일로 WS_EX_DLGMODALFRAME이라는 스타일이 있다.
이 4가지 스타일은 상호배치 되는 스타일이기 때문에 2개 이상 같이 쓸 수 없다.
WS_BORDER는 크기 조정이 안되지만 WS_THICKFRAME은 크기 조정이 된다.
WS_CAPTION은 WS_BORDER와 WS_DLGFRAME이 합쳐진 상수


> 타이틀 바의 버튼
속성으로는 WS_MAXIMIZEBOX, WS_MINIMIZEBOX가 있다. 이 속성들은 WS_EX_CONTEXTHELP 확장 스타일과 함께 사용될 수 없다.
WS_SYSMENU 스타일이 반드시 지정되어 있어야 한다.
(WS_OVERLAPPEDWINDOW & ~WS_SYSMENU로 지정하니까 최대, 최소 버튼이 적용되지 않음)
참고로 닫기 버튼은 윈도우 클래스의 CS_NOCLOSE 스타일로 지정한다.


> 스크롤 바
WS_H(V)SCROLL 스타일


> 초기상태지정
WS_VISIBLE (ShowWindow() 호출 안해도 됨)
메인 윈도우는 nCmdShow 값에 따라 초기 상태를 결정하는 것이 좋다.

WS_DISABLED는 윈도우 사용 금지 스타일
실행중에 윈도우의 사용금지를 토글시킬때는 EnableWindow() 함수를 사용한다.


> 클리핑 스타일
WS_CLIPSIBLINGS, WS_CLIPHILDREN 등은 윈도우와 자식 윈도우간의 클리핑 영역 설정에 영향을 준다.
클리핑 : 그리기에 사용됨


> 확장 스타일
HWND CreateWindowEx(DWORD dwExStyle, ....);
첫번째 인수를 제외하고 CreateWindow() 함수와 완전히 동일하다.
CreateWindow() 호출 시 CreateWindowEx(0, ...)을 호출
확장 스타일은 WS_EX_로 시작됨.


[중복된 멤버]
WNDCLASS의 멤버와 CreateWindow 함수의 인수 사이에는 중복된 것들이 4가지 있다.
바로 스타일, 메뉴 핸들, 클래스 이름, 인스턴스 핸들

- 클래스 이름 : 윈도우 클래스에서는 등록, 윈도우 생성 함수에서는 사용

- 인스턴스 핸들 : hInstance는 파괴 시기를 결정하기 위해 존재하는 인수인데 윈도우 클래스나 윈도우나
둘 다 이를 만든 프로그램이 종료되면 자동으로 파괴 또는 등록 취소되어야 한다.

- 스타일 : 윈도우 클래스 스타일, 생성 할 윈도우 스타일 (비슷한것 같지만 설정되는 스타일이 다르다.)
윈도우 클래스 스타일은 좀 더 공통적인 스타일이고, 윈도우 스타일은 해당 윈도우의 고유 스타일에 가깝다.

- 메뉴 핸들 : 이건 그냥 어느쪽에 등록할 수 있도록 편의를 위해 만들어진것. 
만약 서로 다른 메뉴 핸들값을 준다면? 윈도우 생성시 지정한 메뉴가 우선이다.


[차일드 윈도우]
- Childs 예제를 보면 윈도우 생성 시 모두 x, y, w, h를 0으로 주었는데 
메인 윈도우의 사이즈가 변경되면 연쇄적으로 차일드 윈도우에도 WM_SIZE가 전달되기 때문에
메인 윈도우의 프로시저의 WM_CREATE 메시지 처리 부분에서 메인 윈도우의 사이즈를 변경함으로써
차일드 윈도우에 WM_SIZE메시지가 연쇄적으로 전달된다.
- 차일드는 WM_DESTROY를 처리하지 않아도 되며, PostQuitMessage()를 호출할 필요도 해서도 안된다.
- 만약 메인 윈도우의 작업영역을 자식 윈도우가 전부 덮게 된다면 별도의 배경 브러시를 가질 필요가 없고
WM_PAINT를 처리 할 필요도 없다. 만약 윈도우가 배경 브러시를 가지면 크기가 변경될 때마다
차일드를 지웠다가 다시 그리므로 깜박이는 현상이 계속 생길 것이다. 
그럴때 메인 윈도우에 WM_CLIPCHILDREN 스타일을 주어 차일드가 차지한 영역은 그리기를 아예 제외시켜 버리는 것도 좋은 방법이다.

-> 차일드로 완전히 분할되어 있는 윈도우는 출력할 내용이 없으므로 WM_CREATE, WM_SIZE에서 차일드를 생성, 배치 정도만 하면 된다.

[팝업 윈도우]
- 오버랩드 윈도우의 특별한 형태이며, 특성이 오버랩드 윈도우와 유사하다.
경계선도 가질 수 있고, 최대, 최소화될 수도 있으며, 타이틀바도 가질 수 있다.
주로 다이얼로그, 임시 박스, 메시지 상자 등에 쓰임
(팝업 윈도우는 부모 윈도우와 달리 바깥쪽으로 나갈 수 있다.)
vs에 도킹된 패널, 툴바, 워크 스페이스 등은 도킹 상태는 차일드이지만 도킹을 분리하면 팝업이 된다.
(WS_POPUPWINDOW 속성 부여)


[윈도우간의 계층구조]
디렉터리 구조처럼 윈도우간에도 계층구조가 존재한다.
계층구조에서 가장 최상위 루트가 되는 윈도우를 Desktop Window(데스크탑 윈도우)라고 하며, 이 윈도우는 운영체제가 부팅될 때 만들어져
셧다운될 때 파괴된다.
Desktop Window는 화면 전체를 꽉 채우고 있으며, 사용자가 지정한 배경 벽지 비트맵을 보여주는 기능만 가지고 있다.
그리고 모든 응용 프로그램의 부모 윈도우가 된다.

- 각 응용 프로그램은 아주 특별한 경우를 제외하고는 최소한 하나의 윈도우를 가지는데
제일 처음 만들어지며 사용자와 주 인터페이스를 이루는 윈도우를 메인 윈도우(main window)라고 한다.
메인 윈도우의 부모는 데스크탑 윈도우이며, 부모로 가지는 이런 윈도우를 top level window(최상위 윈도우)라고 한다.
차일드 윈도우는 부모 윈도우의 작업 영역(client area)를 벗어날 수 없는데, 만약 벗어나게 되면 그부분이 잘린다는것을 명심하자!

- 윈도우는 부모-자식 관계를 형성하는것 외에 상호간의 소유 관계를 가지고 있다.
소유 관계는 오버랩드, 팝업 윈도우간의 관계이다.(차일드 윈도우 제외)
이때 다른 윈도우를 소유하는 윈도우를 Owner(소유자)라고 하는데 오버랩드 윈도우나 팝업 윈도우만 "소유자"가 될 수 있다.
차일드 윈도우는 소유자가 될 수 없음은 물론이고 소유될 수도 없다.

소유된 윈도우는 항상 소유자 윈도우보다 상위에 위치하며 소유자가 숨거나 파괴되면 같이 숨겨지고 파괴된다.
그러나 소유자의 이동은 소유된 윈도우에 아무런 영향을 주지 않는다.
윈도우간의 소유 관계는 CreateWindow 함수의 hWndParent 인수로 지정하는데 단, hWndParent가 차일드 윈도우인 경우
그 차일드가 소유자가 되지 않고 차일드를 소유하고 있는 윈도우가 소유자가 된다.

예를 들어보자)
메인 윈도우 - 차일드 1, 차일드 2
차일드 1 - 손자 윈도우가 있다.
손자 윈도우를 (팝업 또는 오버랩드)를 만들었는데 이 경우 손자의 소유자는 
차일드 1의 소유자인 메인 윈도우이지 차일드 1이 아니다. 즉, 부모의 부모를 찾아가
차일드가 아닌 최초의 윈도우가 소유자가 되는데 대개의 경우 최상위의 메인 윈도우가 소유자가 된다.

부모-자식 관계와 소유자 관계의 또 다른 차이점은 부모는 실행중에 SetParent() 함수로 변경 할 수 있지만
소유 관계는 한 번 설정되고 난 후에 변경할 수 없다는 점이다.
윈도우의 부모 윈도우를 조사, 설정 시 호출하는 함수이다.
HWND GetParent(HWND hWnd);
HWND SetParent(HWND hWndChild, HWND hWndNewParent);


소유자 조사시 호출하는 함수 GetWindow()
HWND GetWindow(HWND hWnd, UINT uCmd);
만약 지정한 윈도우가 없으면 NULL 반환

///////////////////////////////////////////////////
다시한번 명심!! 차일드 윈도우는 소유관계 자체가 성립하지 않는다.
///////////////////////////////////////////////////


윈도우의 여분 메모리 할당
G(S)etWindowLongPtr, G(S)etClassLongPtr() 함수



[윈도우 프로퍼티]
여분메모리는 윈도우별로 고유한 데이터를 윈도우 자체에 기억시켜 놓을 수 있다는 점에서 무척 편리한 장치이다.
window property는 여분 메모리와 똑같은 목적으로 사용할 수 있는 또 다른 기억장치이다.
프로퍼티는 여분 메모리보다 더 유연하고 편리하며 여분 메모리를 사용하기 곤란할 때에도 사용 할 수 있다는 장점이 있다.

직접 윈도우 클래스를 등록하는 경우라면 cbWndextra에 원하는만큼 여분 메모리를 지정할 수 있지만 
기존에 존재하는 윈도우를 서브 클래싱한 경우는 여분 메모리를 함부로 사용할 수가 없다. 왜냐하면 기존 윈도우가 
여분 메모리를 어떤 용도로 사용하고 있으며 남은 용량은 얼마나 되는지 알아내기 어렵기 때문이다.(edit, button, listbox 등등)

에디트 컨트롤은 6바이트의 여분메모리를 사용하고, 
버튼과 리스트 박스는 각각 4바이트의 여분 메모리를 사용하는데
여기까지는 알아낼 수 있다 하더라도 이 컨트롤이 여분 메모리를 어떤 용도로 어떻게 사용하는지는 
공개되어 있지 않으므로 정확하게 알 수 없다.

이럴 때 여분 메모리 대신 프로퍼티를 사용할 수 있다.
프로퍼티 : 윈도우에 저장되는 고유 데이터
BOOL SetProp(HWND hWnd, LPCTSTR lpString, HANDLE hData);
HANDLE GetProp(HWND hWnd, LPCTSTR lpString);
HANDLE RemoveProp(HWND hWnd, LPCTSTR lpString);


여기서 한번 생각해보자. 윈도우즈는 왜 똑같은 목적에 쓸 수 있는 두 가지 방법을 제공하는 걸까?
과거에는 이런 목적에 쓸 수 있는 장치가 여분 메모리밖에 없었다. 
그런데 여분 메모리는 윈도우 클래스를 등록할 때 미리 필요한 양을 경정해야 하고
한번 정하면 크기를 함부로 바꿀 수 없으며 읽고 쓸 때 오프셋을 사용하므로 불편하기도 하다.

그래서 32비트로 업그레이드하면서 이런 불편한 여분 메모리를 대신할 수 있는 좀 더 편리한 방법을 고안했는데,
그 결과로 만들어진 것이 바로 프로퍼티이다.
즉, 여분 메모리는 16비트의 구식 방식이고 프로퍼티는 32비트의 신형 방식이라고 할 수 있다.
프로퍼티는 실행중에 필요하면 언제든지 설정, 변경, 추가, 삭제 할 수 있으므로 미리 크기를 결정할 필요도 없고
이름을 줄 수 있으므로 기억된 값의 의미를 쉽게 표현할 수 있다.


[과제] Childs2
Childs 예제의 차일드 배치를 변경해 보자. hC2가 높이 200으로 메인 윈도우의 위쪽에 배치되고 
그 아래쪽에는 hC1과 hC3가 절반씩의 폭을 가지도록 한다.
그리고 hC1에 있는 버튼과 에디트는 hC1의 바닥에 정렬해 보자.

