[윈도우 프로시저]
도스와 윈도우의 가장 큰 차이점은 메시지 처리 시스템이다.
- LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
: 운영체제에 의해 호출되는 콜백함수이다. 그래서 사용자가 이 함수를 직접 호출할 수는 없다.
그래서 SendMessage() 같은 함수를 통해 간접적으로 호출해야 한다.

윈도우 프로시저는 재진압(ReEntrant)이 가능한 함수이다. 
재진입이 가능하다는 것은 WndProc 실행 중에 또 WndProc이 호출될 수 있다는 뜻이다.


[메시지 큐]
: 윈도우즈라는 운영체제는 끊임없는 메시지의 생성과 처리를 무수히 반복하면서 실행되는 것이다.
메시지 큐는 크게 메시지 큐로 들어가는 Queue(큐) 메시지와 큐에 들어가지 않고 
곧바로 윈도우 프로시저로 보내지는 Non Queue(비큐) 메시지로 구분된다.

* 큐 메시지는 주로 사용자의 입력으로부터 발생되는데 WM_KEYDOWN, WM_LBUTTONDOWN 등이 대표적이며,
큐 메시지는 발생 직후 시스템 메시지 큐에 저장되어 스레드 메시지 큐로 보내지며 
최종적으로 윈도우 프로시저에 의해 입력된 순서대로 처리된다.
(메시지 큐는 처리할 메시지를 대기시키는 완충 역할도 한다. 앞에서 메시지 처리량이 많다면....)

* 비큐 메시지는 윈도우에게 특정 사실을 알리거나 명령을 보내기 위해 큐를 통하지 않고 
바로 윈도우 프로시저로 보내지는 메시지이며 대부분의 메시지들은 비큐 메시지이다.
메시지 큐와 메시지 루프를 거치지 않으므로 신속하게 처리된다.
(WM_CREATE, WM_DESTORY, WM_SIZE, WM_MOVE, WM_ACTIVATE 등)
어떤 메시지는 몇 가지 조건의 조합에 의해 여러 가지 메시지를 추가로 발생시키기도 한다.
예)
키 입력 시 WM_KEYDOWN + TranslateMessage() 함수에 의해 WM_CHAR가 추가 발생
윈도우 닫기 버튼 클릭 시 WM_CLOSE + DestroyWindow() 함수 호출하여 + WM_DESTROY가 추가 발생

운영체제는 하나의 시스템 메시지 큐를 관리하며 또한 각 스레드별로 하나씩 메시지 큐를 생성한다.
시스템 메시지 큐는 시스템 전체에 유일한 메시지 큐이며 모든 큐 메시지는 먼저 이곳에 저장된다.
사용자가 마우스를 조작하거나 키보드를 두드리면 
이 입력은 디바이스 드라이버에 의해 메시지로 변환되어 시스템 메세지 큐에 넣어진다.

시스템은 큐의 메시지를 하나씩 꺼내 어떤 스레드로 보낼 메시지인지 판단하여 스레드 메시지 큐로 보내고
시스템 메시지 큐에서 메시지를 지운다.
이 작업을 하는 프로세스를 시스템 아이들(System Idle)이라고 하는데 작업 관리자로 확인해 보면
항상 백그라운드에서 실행중이라는 것을 알 수 있다.
스레드 메시지 큐에 들어온 메시지는 메시지 루프에 의해 꺼내지며 이 메시지는
윈도우의 윈도우 프로시저로 보내져 처리되고 스레드 메시지 큐에서 삭제된다.

※ 정리 : (메시지) 시스템 메시지 큐 -> (시스템 아이들에 의해) 스레드 메시지 큐
-> (메시지 루프에서) 윈도우의 윈도우 프로시저 -> 처리

메시지는 최종적으로 윈도우에게 전달되지만 윈도우 하나당 메시지 큐가 하나씩 있는 것이 아님을 유의하자.
메시지 큐는 스레드당 하나씩 생성되는 것이다. 스레드에 윈도우가 여러 개 있더라도 메시지 자체에 어떤
윈도우로 보내질 메시지인지 정보가 있기 때문에 
스레드 메시지 큐에 여러 윈도우의 메시지가 섞여 있어도 전혀 문제될 것이 없다.

스레드당 하나의 메시지 큐가 생성되지만 그렇다고 해서 모든 스레드가 메시지 큐를 가지는 것은 아니다.
왜냐하면 윈도우를 전혀 가지지 않는 작업 스레드는 메시지를 받아들이지 않으며 따라서
메시지 큐를 가질 필요가 없기 떄문이다. 그래서 시스템은 스레드를 생성할 때 
디폴트로 메시지 큐를 가지지 않는 상태로 만든다. 
스레드 최초 GDI, User 함수 호출 시에 메시지 큐가 생성됨


[메시지 루프]
<메시지 구조체>
struct tagMSG
{
	HWND hWnd;
	UINT message;
	WPARAM wParam;
	LPARAM lParam;
	DWORD time;
	POINT pt;
} MSG;
메시지 구조체 정보에는 메시지 발생 시간(time)과 발생시의 마우스 좌표(pt)에 대한 정보도 들어있다.
그러나 모든 메시지들이 필요로 하는 정보가 아니므로 WndProc까지 전달되지는 않는다.
필요한경우 직접 조사해야 한다.
- DWORD GetMessagePos(VOID);
- LONG GetMessageTime(VOID);

- BOOL GetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFileterMin, UINT wMsgFilterMax);
: 이 함수는 스레드 메시지 큐에 대기중인 메시지를 꺼내 첫 번째 인수로 전달된 MSG 구조체에 복사한다.
그리고 이 메시지를 큐에서 제거하고 TRUE를 리턴하되 만약 큐에서 꺼내온 메시지가 WM_QUIT라면 FLASE를 리턴한다.
나머지 인수들은 Message Filtering에 사용함.
hWnd의 인수에 윈도우 핸들을 주면 이 윈도우와 그 차일드로 보내지는 메시지만 가져오며
NULL이면 현재 스레드에 속한 모든 윈도우의 메시지를 가져온다.

wMsgFilterMin, wMsgFileterMax에 메시지의 범위를 지정하면 이 범위 내의 메시지만 가져오는데
메시지 필터링을 하지 않을 경우는 모두 0으로 지정한다. 메시지 필터링은 특정 종류의 메시지만 꺼내고 싶을 때 사용한다.
이 기능은 시간적으로 나중에 들어온 메시지를 먼저 꺼내며 통상적인 메시지 처리 순서를 어기는 것이므로 잘못 사용하면
프로그램이 무한 대기 상태에 빠지거나 오동작할 위험이 있으므로 섣불리 사용하지 않는 것이 좋다.
- TranslateMessage() : 가상키 입력을 문자 입력으로 바꾸는 역할
- DispatchMessage() : 메시지를 윈도우 프로시저로 보내 처리하는 역할


[PeekMessage()]
- GetMessage()
: 스레드 메시지 큐에서 메시지를 가져오는데 메시지가 없으면
새로운 메시지가 전달될 때까지 리턴하지 않는다.
그래서 남는 CPU시간을 다른 프로세스가 쓸 수 있도록 양보하고, 이로써 멀티 태스킹이 부드럽게 이루어진다.
이렇게 GetMessage()에서 놀고 있는 시간을 Dead Time이라고 하는데 CPU가 월등히 빠르기 때문에
Dead Time의 비율이 꽤 높은 편이다.
데드 타임을 잘 활용하면 애니메이션이나 틈틈이 해야 할 일을 다른 작업 시간에 영향을 주지 않고도 할 수 있다.
그런데 문제는 GetMessage() 함수가 메시지를 받기 전에는 절대로 리턴하지 않기 때문에
데드 타임을 활용할 수 없다는 점이다.

- BOOL PeekMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
: 메시지가 없더라도 즉각 리턴한다. TRUE - 메시지가 있다, FALSE - 메시지가 없다
wRemoveMsg : 메시지가 있을 경우 이 메시지를 큐에서 제거할 것인가 아닌가를 지정하는데
PM_REMOVE이면 GetMessage 처럼 메시지를 큐에서 제거하지만, PM_NOREMOVE이면 제거하지 않을 수도 있다.
즉, 어떤 메시지가 있는지 엿보기만 가능하다는 소리이다.
>>>> 1. 데드타임 활용 가능 2. 메시지 엿보기 가능

PeekMeesage2예제를 보면 다른 메시지를 처리하는 중에 큐에서 메시지를 꺼내는 코드를 추가하여
점을 찍는 중에도 다른 작업을 할 수 있도록 하였다.
그리고 이런 코드를 "메시지 펌프" 라고 한다. 타이머로 분할하기 힘들거나 모달 대화상자처럼
사용자 응답을 받을 때까지 실행해야 하는 작업은 이런 식으로 장시간의 루프를 돌리되 
메시지 펌프를 중간에 삽입해 놓으면 작업을 하는 중에도 다른 급한 작업을 처리할 수 있다.(쉽게 말해 백그라운드 작업)


[Idle Time]
응용 프로그램이 아무것도 하지 않고 노는 시간을 Idle Time(아이들 타임) 또는 Dead Time(데드 타임) 이라고 한다.
실제로 CPU 사용율을 점검해봐도 확인 가능하며 가끔씩 전달되는 메시지도 매우 빨리 처리되기 때문에 버려지는 시간이 많다.

Idle Time에 할만한 작업으로는 툴바, 상태란 등의 상태 갱신, 사용하지 않는 자원의 회수, 단순 장식을 위한 애니메이션 등이 있다.
Idle Time의 특징은 수시로 해야 하되 결코 긴급하지 않으며 속도를 희생해 가면서까지 정확할 필요도 없다는 점이다.

그렇다면 이러 버려지는 시간은 언제일까?
주기적으로 해야 할 작업이라면 타이머를 떠올릴 수 있겠지만, 타이머는 해상도가 낮고 
타이머 메시지는 처리되는 메시지중에 우선순위가 가장 낮다.
멀티 스레드를 생각 할 수 있는데 이 또한 긴급하지도 않은 아이들 작업 때문에 
스레드를 쓰는 것은 격이 맞지 않다.

결국 진정한 의미의 Idle Time은 메시지 루프에서 메시지를 꺼내지 못하고 있는 상태에 해당되므로
읽을 메시지가 없더라도 즉시 리턴하는 PeekMessage()가 해답이 될 수 있다.

그러나 Idle Time을 활용하는 것은 멀티 태스킹 환경에서는 용납되지 않는다.
자기 자신의 버려진 시간은 효율적으로 잘 사용하고 있지만 함께 실행되는 다른 프로그램들이 CPU를
거의 활용하지 못하기 때문이다. 이렇게 CPU 시간을 받지 못해 굶고 있는 상황을 기아 상태라고 한다.

최신 CPU들은 자신이 해야 할 일의 양에 따라 동작 클럭을 자동으로 조정하여 
전원을 관리하는 기능(Speed Step)이 포함되어 있는데
FindIdle과 같은 프로그램은 이러한 기능을 방해한다. 데스크톱이면 상관 없는데 모바일 환경에서는 큰 문제를 유발한다.


[키 상태 조사하기]
WM_KEYDOWN 메시지를 받으면 키가 입력되는 시점을 알 수 있으며 이때 wParam을 읽어 어떤 키가 눌러졌는지 조사한다.
계속 누르고 있으면 키보드의 반복 입력 기능에 의해 연속해서 WM_KEYDOWN 메시지가 전달된다. (키의 상태는 알 수 없음)

두 개의 키를 누를 경우 먼저 누른 키에 대해서는 더 이상 WM_KEYDOWN 메시지가 전달되지 않는다.
A -> B를 누르면 B에 대한 WM_KEYDOWN 메시지가 전달됨
키의 현재 상태를 조사하는 함수
- SHORT GetKeyState(int nVirtKey);
- SHORT GetAsyncKeyState(int vKey);
: 두 함수 모두 조사하고 싶은 가상 키 코드를 인수로 전달받는다.
일반 키일 경우 눌러졌으면 최상위 비트(MSB)가 1로 설정되고 그렇지 않으면 0으로 설정된다.
그래서 리턴값을 0x8000과 &연산을 하면 눌렸는지 확인할 수 있다. 

GetKeyState() 함수는 메시지 입력 시점의 키 상태를 조사 (메시지 루프를 거쳐서 메시지 큐에 쌓임)
(만약 운영체제가 할일이 많아서 해당 메시지가 큐에 쌓이게 된다면 의도하지 않는 동작이 생길 수 있다)

GetKeyAsyncState() 함수는 메시지 처리 시점의 키 상태를 조사 (메시지 큐를 거치지 않고 바로 리턴해줌)