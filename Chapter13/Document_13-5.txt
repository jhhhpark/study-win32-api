[사용자 정의 메시지]

[메시지 범위]
메시지의 명칭은 흔히 WM_XXXXX 등과 같은 매크로 상수로 나타내는에 이 매크로의 실제 값은 정수로 정의되어 있다.
메시지 ID는 WinUser.h에 정의되어 있다.

사실 프로그래밍 할 때 메시지 ID의 실제 상수값은 굳이 몰라도 상관없지만
저수준 디버깅을 할 때는 매크로 상수를 볼 수 없으므로 이 값을 알아야 하는 경우도 가끔 있는데
GetMessage가 방금 꺼낸 메시지가 무엇인지 알고싶다면 번호를 참조해야 한다.
메시지의 형은 UINT이므로 종류만 해도 약 40억개까지 정의 가능하다.

실제로 메시지는 천 개도 안 되지만 나머지 ID는 대부분 특수한 용도로 예약되어 있다.
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
<0 ~ WM_USER-1> : 시스템 메시지용으로 예약되어 있으며 WM_로 시작되는 대부분의 메시지는 이 영역에 예약되어 있다.
이 영역중 비어있는 값은 미래의 사용을 위해 예약되어 있으므로 사용자가 사용할 수 없다.

<WM_USER ~ WM_APP-1> : 응용 프로그램이 자신의 필요에 따라 사용할 수 있는 메시지 영역이다.
내부적인 용도로만 사용해야 하며 응용 프로그램간의 통신을 위해 이 영역의 메시지를 사용해서는 안 된다.
버튼, 에디트 등의 컨트롤이 이 영역의 메시지를 이미 사용하고 있기 때문에 
이 영역에 또 다른 메시지를 정의할 경우 메시지간의 충돌이 발생할 수 있다.
단, 응용 프로그램끼리 메시지의 의미를 분명히 알 수 있을 때는 이 영역의 메시지를 사용할 수도 있다.

<WM_APP ~ 0XBFFF> : 응용 프로그램이 개별적인 용도로 사용할 수 있는 영역이며 시스템은 이 영역의 메시지를 전혀 사용하지 않는다.

<0xc000 ~ 0xFFFF> : 이 영역의 메시지는 실행중에 메시지를 등록하는 별도의 함수에 의해 정의된다.
복수 개의 응용 프로그램이 같은 이름으로 메시지를 등록할 수 있으므로
응용 프로그램간의 통신에 사용될 수 있다.

<0xFFFF ~ > : 장래의 사용을 위해 예약된 영역이다. Win16에서 Win32로 업그레이드되면서
새로 생긴 영역인데 아마 앞으로도 이 영역은 사용되지 않을 것으로 전망된다.
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------

WM_USER은 0x400으로 정의되어 있으며 WM_APP는 0x8000으로 정의되어 있다.
|-----------|-----------------|----------------|--------------------|-------------|
0  시스템 0x400 내부 통신용 0x8000 외부 통신용 0xC000 문자열 메시지 0x10000   예약   40억

그런데 이러한 메시지 ID의 배치상태는 굳이 외울 필요는 없고
WM_USER 이후의 값을 가진다는 정도만 이해하면 된다.


[사용자 정의 메시지]
메시지는 어차피 약속이기 때문에 메시지의 의미는 응용 프로그램이 정하기 나름이며
wParam, lParam의 용도도 편한대로 정해 사용할 수 있다.
단, 기존의 메시지 ID 영역을 침범하지 말아야 하며 정해진 절차를 따라야 한다.
응용 프로그램이 직접 만들어 쓰는 메시지를 사용자 정의 메시지(User Defiend Message)라고 한다.

그런데 굳이 메시지를 따로 정의해서 SendMessage()로 메시지를 전달할 필요가 있나??
특정 함수를 호출하게 하는것이 좀더 나을꺼라고 생각 할 수 있지만,
메시지는 훨씬 더 호출 범위가 넓어서 프로세스의 경계를 넘어설 수도 있다.


[문자열로 메시지 등록하기]
사용자 정의 메시지를 정의할 때는 WM_USER+n 또는 WM_APP+n의 ID를 사용하는데 이때 n의 값은 임의로 정할 수 있으나
통신하고자 하는 프로그램끼리는 서로 n값을 알고 있어야 한다.
그런데 똑같은 WM_USER+n 메시지라도 프로그램별로 의미가 다를 수도 있다.
메시지의 ID는 지역적이므로 통신 당사자끼리만 합의하면 별 문제가 없다.

- UINT RegisterWindowMessage(LPCTSTR lpString);
: 문자열로 받고 싶은 메시지의 이름을 전달하면 이 함수는 어떤 프로그램도 사용하지 않는 빈 ID를 하나 찾아 리턴한다.
만약 등록된 이름이면 등록된 ID를 다시 리턴한다. 두 프로그램이 같은 이름으로 ID를 등록할 경우
같은 메시지 ID를 받게 되며 그래서 통신이 가능해진다.
등록된 ID이므로 이름이 중복되지 않는 한 절대로 이 ID를 다른 프로그램이 사용할 경우란 없으며
그래서 좀 더 안전한다.
>>>> ResMsg1, ResMsg2 예제를 함께 실행해보면 각각 RegisterWindowMesasge()를 통해 동일한 문자열로 등록한 메시지는
동일한 ID를 발급받을 것을 확인 할 수 있다.

[과제] UserMes2
UserMes와 SendUserMes 예제를 "SoriMessage"라는 이름의 문자열 메시지로 통신하도록 수정해 보아라.
이렇게 되면 UserMes 프로그램은 임의의 프로그램으로부터 메시지를 받을 수 있다.