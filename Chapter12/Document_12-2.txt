[윈도우 관련 메시지]


[생성]
윈도우 생성(CreateWindow)시 응용 프로그램으로 차례대로 메시지가 전달된다.
1. 비작업영역이 생성되고 난 직후에 WM_NCCREATE 메시지 전달.
2. 작업 영역이 생성된 직후에 WM_CREATE 메시지 전달.
결국 윈도우 생성시 가장 먼저 전달되는 메시지가 WM_NCCREATE 이며, 객체화를 할때 중요하게 사용되지만 큰 실용성은 없다.
그래서 DefWindowProc으로 넘기는 것이 가장 무난하다.

WM_CREATE : 초기화 작업을 하는데 전달되는 시점이 윈도우가 메모리상에 생성되고, 화면에 보이기 직전에 전달된다.
따라서 hWnd가 유효하므로 윈도우 상태를 변경하는 함수들을 호출 할 수 있다. (1회만 전달)

WinProc에서 lParam : 두 메시지 처리 시 모두 lParam으로 CREATESTRUCT 구조체를 전달받으며 
이 구조체를 참조하면 CreateWindow에서 지정한 인수를 모두 조사할 수 있다.
그리고 CreateWindow() 함수의 마지막 인수인 lParam은 사용자 정의 데이터이다.(크게 중요하지는 않으며 보통 NULL)
해당 데이터는 WndProc의 lParam을 CREATESTRUCT 구조체 포인터로 형변환하여 lpCreateParams를 통해 전달받을 수 있다.

이 파라미터는 윈도우 생성시에 딱 한번만 전달되므로 별도의 변수에 저장해 놓지 않으면 이후 이 값을 참조할 수 없다.
그리고 만약 사본을 뜰거면 구조체를 통째로 복사하는게 좋다.(DEEP COPY)
이 인수가 반드시 정적이라고 보장할 수 없기 때문이다. (CreateStruct 예제에서는 통째로 복사하고 있음)


[파괴]
윈도우 파괴시 보내지는 메시지는 다음과 같다.
사용자가 시스템 메뉴에서 닫기 명령을 선택 or 타이틀 바의 X버튼을 클릭하면 WM_CLOSE 메시지가 전달된다.
이 메시지를 DefWindowProc()로 넘기면 디폴트로 DestroyWindow() 함수를 호출하므로 윈도우가 파괴되는데 
이 메시지를 처리하면 사용자에게 프로그램을 정말 끝낼 것인가를 물어볼 수도 있다.

그리고 나서 WM_DESTROY 메시지와 WM_NCDESTROY 메시지가 전달된다.
이 메시지에서 필요한 종료 처리를 하는데 주로 열려져 있는 파일을 닫고 할당된 메모리나 전역 자원을 해제하는 등의 처리를 한다.
메인 윈도우일 경우 PostQuitMessage() 함수를 호출하여 응용 프로그램을 종료하는 중요한 처리도 해야 한다.
종료 확인을 위해 WM_DESTORY 메시지는 사용할 수 없다. 이미 이메시지를 받았을 때는 윈도우의 파괴가 진행중인 상황이므로 파괴를 멈출 수 없다.
(뭐... 경고 메시지 출력같은 것은 가능하겠지만 말이다.)

WM_CLOSE는 종료하겠냐는 "질문"이지만, WM_DESTROY 종료하겠다는 "통보"에 가깝다.

응용 프로그램의 정상적인 종료 방법은 DestroyWindow() 함수를 호출하여 메인 윈도우를 파괴하는 것이다.
ex) 
RButtonDown을 통해 종료를 원한다면, SendMessage(hWnd, WM_CLOSE, 0, 0);
응용 프로그램 종료 시 저장하지 않은 문서를 저장하고 종료해야 하는 경우가 많은데 이 때도
WM_CLOSE 메시지를 전달하여 해당 메시지 처리 시에 미저장 문서 저장 로직을 실행하는것이 좋다.
그리고 이런 미저장 문서 저장 기능이 필요하다면 WM_CLOSE와 함께 
운영체제가 종료(ShutDown)될 때 전달되는 WM_QUERYENDSESSION 메시지에 대해 꼭 확인해야 한다.


[크기 변경]
윈도우 사이즈 변경 시 전달되는 메시지는 WM_SIZE이다.
어떤 종류의 크기 변경인지를 나타내는 값도 함께 전달된다.
SIZE_MAXHIDE, SIZE_MAXIMIZED 등등

LOWORD(lParam) : 작업영역의 폭
HIWOER(lParam) : 작업영역의 높이
이 메시지에서 윈도우의 모양이 달라지거나, 차일드의 위치를 재정렬한다.

wParam값 중 특히 SIZE_MINIMIZED에 대해서는 
다소 특별한 처리가 요구되는 경우가 많은데 최소화할 때는 작업영역의 폭이 0이 되므로 평상시와는 조금 다르게 처리해야 한다.
폭이 0인 윈도우에 대해 문서의 길이는 무한대가 되어 버리기 때문에 
통상적으로 WM_SIZE에서는 if (wParam != SIZE_MINIMIZED) { }인 경우가 많다.

WM_SIZEING 메시지는 사용자가 윈도우 크기를 변경하고 있을 때 보내진다.
이 메시지의 wParam에는 사용자가 드래그하고 있는 윈도우의 경계선이 어느쪽인가를 지정하는 WMSZ_BOTTOM, WMSZ_LEFT, WMSZ_TOP 등의 값이 전달되며
lParam에는 현재 윈도우의 영역을 화면 좌표로 가지는 RECT 구조체의 포인터가 전달된다.

WM_SIZING은 경계선을 드래그 하는 중에 지속적으로 전달되지만, 
WM_SIZE는 드래그를 마치고 버튼을 놓는 순간에 단 한번만 전달된다.
그러나 바탕화면 등록 정보의 "마우스 끄는 동안 창 내용 표시" 옵션이 켜져 있으면 WM_SIZE도 드래그 하는 중에 매번 전달된다.

윈도우 크기 변경 메시지 중에는 WM_GETMINMAXINFO 메시지도 있다.
운영체제는 윈도우의 크기나 위치를 바꾸기 전에 이 메시지를 응용 프로그램을 보내어 위치와 크기에 대해 제한을 할 수 있는 기회를 준다.
이 메시지 처리 시 tagMINMAXINFO 구조체가 lParam을 통해 전달된다.

ptMaxSize, ptMaxPosition은 최대화 시 크기와 위치를 지정
ptMinTrackSize, ptMaxTrackSize는 경계선을 드래그하여 지정할 수 있는 윈도우의 최소, 최대 크기를 제한
ex) MinMax 예제 참조

WM_GETMINMAXINFO 메시지는 지금까지 윌가 사용해왔던 메시지와는 약간 다른 면이 있다.
일반적으로 메시지는 운영체제가 윈도우에게 사건의 발생을 알려주는 것이지만 이 메시지의 경우처럼
운영체제가 윈도우에게 질문을 하는 경우도 있다. 즉 이메시지는 응용 프로그램이 리턴값을 구조체에 채워서
돌려보내며 운영체제는 응용 프로그램이 제공한 정보를 참고하여 사용한다.
이와 같이 출력용 인수를 통한 리턴값이 중요한 의미를 가지는 메시지도 있다.
윈도우의 크기를 일정하게 제한하는 문제는 윈도우의 크기와 관련된 처리이므로 WM_SIZE 메시지를 받았을 때 처리하는 것이 옳다고 생각할 수 있다.
EX)
	case WM_SIZE:
		GetWindowRect(hWnd, &wrt);
		Width = wrt.right - wrt.left;
		Height = wrt.bottom - wrt.top;
		Width = min(max(Width, 300), 600);
		Height = min(max(Height, 200), 400);
		SetWindowPos(hWnd, 0, 0, 0, Width, Height, SWP_NOMOVE);
		return 0;

강제로 크기 조정을 할 수 있는데 WM_SIZE 메시지 는 이미 윈도우 크기가 바뀐 다음에 전달되는 메시지이기 때문에 이때 갖ㅇ제로
크기를 줄이면 깜박거림이 발생하는 것이다.
이에 비해 WM_GETINMAXINDO 메시지는 운영체제가 응용 프로그램에게 희망하는 크기를 제한하기 위해 기회를 제공하는 메시지이다.
그래서 이 메시지에 응답하면 아직 크기가 변경되기 전이므로 지정한 크기의 범위를 아예 벗어나지 않는다.


[이동]
윈도우가 이동중일 때는 WM_MOVING 메시지가 전달되는데 이 메시지에서 
윈도우의 위치나 크기가 어떻게 변하는가를 감시하거나 강제로 변경할 수 있다.
또한 윈도우의 이동 완료되었을 때는 WM_MOVE 메시지가 잔달된다.
WM_MOVE 메시지에서
LOWORD(lParam) : x
HIWOER(lParam) : y
위 두 메시지는 윈도우 이동과 관련해서만 발생하는데 비해
위치, 크기, Z순서가 변경되었을 때는 다음 메시지가 발생한다.
WM_WINDOWPOSCHANGING : 이동 중
WM_WINDOWPOSCHANGED : 이동 완료 시
두 메시지가 전달될 때 lParam에는 WINDOWPOS 구조체 포인터가 전달된다.
typdef struct _WINDOWPOS {
	HWND hwnd;
	HWND hwndinsertAfter;
	int x;
	int y;
	int cx;
	int cy;
	UINT flags;
} WINDOWPOS;
이 구조체는 윈도우의 크기, 위치, Z순서를 변경하는 SetWindowPos 함수의 인수와 동일한 멤버를 가지고 있는데
각 멤버의 의미는 이름만으로도 쉽게 알 수 있도록 되어 있다.
WM_WINDOWPOSCHANGING 메시지에서는 이 구조체의 값들을 참고하여 현재 위치와 크기를 알 수 있으며 뿐만 아니라
강제로 값을 변경하여 위치를 조정할 수도 있다.

이것을 활용하는 예에는 포토샵의 툴바 윈도우를 드래그하다가 메인 윈도우의 벽 근처에 가면 착 하고 달라붙는 것을 확인할 수 있는데
이런 처리가 바로 WM_WINDOWPOSCHANGING 메시지를 이용하는 것이다.

팝업 윈도우를 부모 윈도우의 가장자리에 밀착시키는 것 역시 이와 동일하다.
Moving 예제에서 화면 좌표(sx, sy)대시 부모 윈도우의 좌표를 사용하면 된다.
WM_MOVE 나 WM_MOVING은 이동 사실을 알리는 단순한 신호일 뿐이므로 이런 처리에는 부적합하다.


[액티브 상태 변경]
스크린상의 많은 윈도우 중 오직 입력을 받을 수 있는 Active(활성)윈도우는 오직 하나이다.
사용자는 키보드나 마우스를 통해 수시로 Active 윈도우를 변경 할 수 있다.
이 때 세가지 메시지가 차례대로 전달된다.
WM_ACTIVATEAPP 메시지 : 응용 프로그램이 활성화되거나 비활성화될 때 보내진다.
wParam이 TRUE이면 이 메시지를 받은 프로그램이 활성화되는 것이고 FALSE이면 비활성화되는 것이다.
lParam으로 활성화 상태가 변경될 때 상대편 윈도우를 소유한 스레드의 ID가 전달된다.
WM_NCACTIVATE 메시지는 비작업영역의 활성화 상태가 변경될 때 보내지는데 wParam이 TRUE이면 활성화,
FALSE이면 비활성화되는 것이다. 이 메시지는 보통 DefWindowProc()에서 처리하는게 무난하다.
WM_ACTIVATE 메시지는 활성화 상태가 변경되는 개별 윈도우에게 보내지는 메시지이다. (WM_ACTIVATE를 가장 많이 쓸듯)
wParam의 하위 워드에는 윈도우의 활성화 여부를 나타내는 다음과 같은 값들이 전달된다.
WA_INACTIVE : 윈도우가 비활성화되었다.
WA_CLICKACTIVE : 마우스 클릭에 의해 윈도우가 활성화되었다.
WA_ACTIVE : 마우스 클릭 이외의 방법, 예를 들어 키보드나 또는 SetActiveWindow 등의 함수 호출에 의해 윈도우가 활성화되었다.

wParam의 상위 워드에는 윈도우가 최소화 상태인가 아닌가를 전달하는데 
상위 워드가 0이외의 값을 가지면 윈도우가 최소화되어 있는 것이다.
lParam은 윈도우의 활성화/비활성화에 따라 활성상태가 변경된 상대편 윈도우의 핸들이 전달된다.
ex) 
A, B윈도우가 있는데 A윈도우가 현재 활성상태임.
이 때 마우스 클릭하여 B윈도를 활성화하면 wParam 하위 워드에는 WA_CLICKACTIVE메시지가 전달되고,
wParam의 상위 워드에는 0, lParam에는 A윈도우의 핸들값이 전달된다.
(물론 경우에 따라서 NULL이 될 수도 있다.)

정리-> 응용 프로그램이 활성/비활성화 시 메인 윈도우로 WM_ACTIVATEAPP, 
윈도우가 활성/비활성화 시 WM_ACTIVATE 메시지가 보내짐
(단, 같은 프로그램 내 윈도우끼리 활성화 상태가 변경될 때는 당연히 WM_ACTIVATEAPP이 전달되지 않음)

Focus : 입력 초점, 키보드 입력을 받을 수 있는 상태 (한번에 하나의 윈도우만 포커싱 될 수 있다.)
윈도우의 FOCUS가 변경될때는 WM_SETFOCUS, WM_KILLFOCUS 메시지가 전달된다.
이때 wParam으로는 포커스를 잃게 되는 윈도우의 핸들 또는 새로 포커스를 얻게 되는 윈도우 핸들이 전달된다.
- void SetFocus(HWND) : 포커스를 강제로 옮길 때 사용하는 함수
- HWND GetFocus() : 현재 포커스를 가진 윈도우 조사하는 함수
(제한 있음!! 같은 스레드에 속한 윈도우로만 한정된다.)

WM_ACTIVATE와 WM_SETFOCUS는 비슷한 것 같지만 다르다.
WM_ACTIVATE : 일반적인 활성화
WM_SETFOCUS : 키보드 입력을 받을 수 있는 상태
이 두 메시지의 공통점이라면 차일드에게 직접 전달되지 않는다는 것인데 항상 최상위 윈도우가 이 메시지를 먼저 받는다.
차일드쪽에 포커싱을 주고 싶다면 SetFocus()를 통해 줄 수 있다.
이러면 차일드 쪽에서 WM_SETFOCUS 메시지를 전달 받는다. 결국 WM_ACTIVATE는 차일드에게 허용되지 않는 상태이며,
오버랩드와 팝업에만 전달된다.


[상태 변경]
WM_SHOWWINDOW : 윈도우가 보여지거나 숨겨지기 직전에 보내지는데 wParam이 TRUE이면 윈도우가 보이기 직전이며 FALSE이면 숨겨지기 직전이다.
이때 lParam : 윈도우의 상태가 변경된 이유에 대한 값이다.
SW_OTHERUNZOOM : 최대화되어 있던 다른 윈도우가 복구되면서 이 윈도우의 가려졌던 부분이 드러남
SW_OTHERZOOM : 다른 윈도우가 최대화되면서 이 윈도우가 가려졌다.
SW_PARENTCLOSING : 소유자 윈도우가 최소화되었다.
SW_PARENTOPENING : 소유자 윈도우가 복구되었다.

보이지 않는 윈도우에서 메시지 처리시 활용, 최대/최소화 될 때를 알아내야 한다면 WM_SIZE에서 wParam을 조사하면 된다.
WM_ENABLE : 윈도우의 사용 금지/허가 상태가 변경될 때 보내짐 wParam이 TRUE: 사용 허가/ FALSE: 사용 금지
윈도우는 WS_DISABLE 상태를 주지 않는 한 항상 default로 사용 가능 상태로 생성된다.
만약 사용 허가/금지를 하고 싶다면 EnableWindow() 함수를 사용하면 된다.
(참고로 윈도우가 사용 금지 상태이든 숨겨져있든 간에 입력을 못받거나 할뿐이지 메시지 처리는 할 수 있다.)


[WM_NCHITTEST]
윈도우의 각 부부넹 마우스 커서를 가져가 보면 위치에 따라 커서의 모양이 바뀐다.
크기 조절이 가능한 경계선의 왼쪽변이나 오른쪽변에 커서를 가져가면 커서의 모양이 좌우 화살표 모양으로
변경 되며 위, 아래 경계선에서는 상하 화살표 모양이 된다. 시스템은 윈도우의 어떤 부분인지를 조사할 때
(커서 이동, 마우스 누름) 윈도우에게 WM_NCHITTEST라는 메시지를 먼저 보낸다.

이 메시지의 wParam은 사용되지 않으며 lParam에는 커서의 현재 좌표가 전달된다.
윈도우들은 보통 이 메시지를 처리하지 않고 DefWindowProc으로 전달하는데 이 함수는 lParam의 마우스 위치를 보고
윈도우의 어느 부분에 커서가 있는지를 조사해 다음 값 중 하나를 리턴한다.
HTBORDER(크기 조절이 불가능한 경계선)
HTBOTTOM(아래쪽 경계선)
HTCAPTION(타이틀 바)
....
시스템은 DefWindowProc이 리턴하는 이 값을 참조하여 커서를 바꾸고 디폴트 처리를 한다.
예를 들어 HTCAPTION위에서 마우스 버튼을 눌렀으면 윈도우의 이동 처리를 하며
경계선 위에서 마우스 버튼을 눌렀으면 크기를 변경한다. 이 메시지를 처리하지 않으면 모든 것이 표준적인 윈도우대로 동작하지만
이 메시지를 가로채면 동작 방식을 변경할 수 있다.

시스템은 마우스 커서가 이동하거나 버튼이 눌러질 때 수시로 이 메시지를 보낸다.
윈도우는 이 메시지를 받았을 때 먼저 DefWindowProc을 호출해 마우스 커서가 윈도우의 어느 부분에 있는지를 조사해 본다.
그리고 만약 마우스 커서가 작업영역에 있다면 이를 HTCAPTION 즉, 타이틀 바에 있는것처럼 바꾸어서 리턴하는 예제를 작성해보자.
그러면 이 메시지의 리턴값으로 HTCAPTION을 받으면 디폴트 정의된 동작대로 타이틀 바를 드래그해서 윈도우를 이동하려고 할 것이고
그래서 작업영역을 드래그해서도 윈도우의 위치를 옮길 수 있다.
이 메시지는 정말로 다른 메시지와 달리 리턴값이 아주아주아주 중요한 의미를 갖는다.
(잘못쓰면 사용자에게 엄청난 혼란을 줄 수 있기 때문에 정확한 사용법을 알고 사용해야 한다.)





[과제] Adhere
메인 윈도우 하나와 툴 팔레트에 해당하는 팝업 윈도우 하나를 생성한다. 팝업 윈도우의 닫기 버튼은 쓸 수 없고
회색의 배경색을 주어 툴 팔레트처럼 보이도록 만들자.
크기 조정이 가능한 경계선을 가지지만 폭은 200픽셀로 고정되어 있어 크기 조정을 할 수 없고 높이만 조정할 수 있다.
높이는 부모의 좌우측벽에 30픽셀 미만으로 접근하면 부모의 벽에 밀착시켜 툴 팔레트를 부모와 쉽게 정렬 할 수 있도록 한다.
포토샵같은 그래픽 편집 프로그램의 툴 팔레트에서 볼 수 있듯이 작고 배치하기 쉬운 팝업 윈도우를 만든다고 생각하면 된다.

